
		/** Returns an instruction's location in the ControlFlowGraph.
		*/
		inline location_type get_location(size_t idx) const {
			// This will point you beyond empty blocks.  Great!
			assert(idx < code_.size());
			for ( int i = num_blocks()-1; i >= 0; --i )
				if ( idx >= blocks_[i] )
					return std::make_pair(i, idx - blocks_[i]);

			assert(false);
			return std::make_pair(0,0);
		}

		/** Returns true if the underlying code performs an undefined register read.
		*/
		inline bool performs_undef_read() const {
			for ( auto i = reachable_begin(), ie = reachable_end(); i != ie; ++i ) {
				auto di = def_ins_[*i];
				auto idx = blocks_[*i];
				for ( size_t j = 0, je = num_instrs(*i); j < je; ++j ) {
					const auto& instr = code_[idx++];
					const auto reads = instr.read_set();
					if ( (reads & di) != reads )
						return true;
					di |= instr.write_set();
					di -= instr.undef_set();
				}
			}
			return false;
		}
