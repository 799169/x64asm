The null condition from m.h
		inline bool is_null() const {
			return (get_base().is_null() && get_scale().is_null()) || 
				      get_index() == rsp ||
							get_scale() == scale_null;			     
		}

Everything that used to be in opcode.h

// What's going on here?
// We have 64-bits worth of space for each opcode name.
// That's enough room to fit the answers to most interesting queries.
// This allows us to answer those queries using at most two arithmetic ops.
#define DEF(idx, a, t1, t2, t3, m1, m2, m3, r, j, uj, cj, mi, fr, nw) \
  ((Operand) idx << 50) | \
	((Operand) a   << 48) | \
	((Operand) t3  << 42) | ((Operand) t2 << 36) | ((Operand) t1) << 30 | \
	((Operand) m3  << 27) | ((Operand) m2 << 24) | ((Operand) m1) << 21 | \
	((Operand) r   << 20) | \
	((Operand) j   << 19) | ((Operand) uj << 18) | ((Operand) cj) << 17 | \
	((Operand) mi  << 15) | ((Operand) fr << 13) | ((Operand) nw) << 11

/** Opcodes values.
*/	
#include "src/gen/opcode.enum"

#undef DEF

/** An extended opcode representation that makes argument types explicit.
*/
class Opcode {
	friend class Instruction;

	public:
		inline Opcode() 
				: o_(-1) { 
		}

		inline Opcode(Operand o) 
				: o_(o) {
		}

		inline operator Operand() const {
			return o_;
		}

		inline bool is_null() const {
			return (o_ >> 50) >= domain_.size();
		}

		inline size_t arity() const {
			return (o_ >> 48) & 0x3;
		}

		inline Type type(size_t index) const {
			assert(index < arity());
			return (Type) ((o_ >> (30 + index*6)) & 0x3f);
		}

		inline Modifier modifier(size_t index) const {
			assert(index < arity());
			return (Modifier) ((o_ >> (21 + index*3)) & 0x7);
		}

		inline bool is_label_defn() const {
			return o_ == LABEL_DEFN_64L;
		}

		inline bool is_ret() const {
			return o_ & ((Operand) 0x1 << 20);
		}

		inline bool is_jump() const {
			return o_ & ((Operand) 0x1 << 19);
		}

		inline bool is_cond_jump() const {
			return o_ & ((Operand) 0x1 << 17);
		}

		inline bool is_uncond_jump() const {
			return o_ & ((Operand) 0x1 << 18);
		}

    inline bool touches_mem() const {
			return mem_index() != 3;
		}

		inline Modifier mem_modifier() const {
			assert(touches_mem());
			return modifier(mem_index());
		}

		inline size_t mem_index() const {
			return (o_ >> 15) & 0x3;
		}

		inline RegSet implicit_read_set() const {
			assert((o_ >> 50) < implicit_read_set_.size());
			return implicit_read_set_[o_ >> 50];
		}

		inline RegSet implicit_write_set() const {
			assert((o_ >> 50) < implicit_write_set_.size());
			return implicit_write_set_[o_ >> 50];
		}

		inline RegSet implicit_undef_set() const {
			assert((o_ >> 50) < implicit_undef_set_.size());
			return implicit_undef_set_[o_ >> 50];
		}

		typedef const std::vector<Opcode>::const_iterator iterator;

		static iterator begin() {
			return domain_.begin();
		}

		static iterator end() {
			return domain_.end();
		}

	private:
		Operand o_;

		static const std::vector<RegSet> implicit_read_set_;
		static const std::vector<RegSet> implicit_write_set_;
		static const std::vector<RegSet> implicit_undef_set_;

		static const std::vector<Opcode> domain_;

		inline size_t first_read() const {
			return (o_ >> 13) & 0x3;
		}

		inline size_t num_writes() const {
			return (o_ >> 11) & 0x3;
		}
};

extern const Opcode opcode_null;
#endif



EVERYTHING THAT WAS IN instruction.h

		bool is_null() const;

		inline Opcode get_opcode() const { 
			return opcode_; 
		}

		inline void set_opcode(Opcode o) {
			opcode_ = o;
		}

		inline Operand get_operand(size_t index) const {
			assert(index < arity());
			return operands_[index];
		}

		inline void set_operand(size_t index, Operand o) {
			assert(index < arity());
			operands_[index] = o;
		}

		inline size_t arity() const { 
			return opcode_.arity(); 
		}

		inline Type type(size_t index) const { 
			return opcode_.type(index); 
		}

		inline Modifier modifier(size_t index) const {
			return opcode_.modifier(index);
		}

		inline bool is_label_defn() const {
			return opcode_.is_label_defn();
		}

		inline bool is_ret() const {
			return opcode_.is_ret();
		}

		inline bool is_cond_jump() const {
			return opcode_.is_cond_jump();
		}

		inline bool is_uncond_jump() const {
			return opcode_.is_uncond_jump();
		}

		inline bool is_jump() const {
			return opcode_.is_jump();
		}

		inline bool touches_mem() const {
			return opcode_.touches_mem();
		}

		inline Modifier mem_modifier() const {
			return opcode_.mem_modifier();
		}

		inline size_t mem_index() const {
			return opcode_.mem_index();
		}

		inline bool touches_stack() const {
			const auto mi = opcode_.mem_index();
			if ( mi == 3 )
				return false;
			return ((M)get_operand(mi)).is_stack();
		}

		inline Modifier stack_modifier() const {
			assert(touches_stack());
			return modifier(opcode_.mem_index());
		}

		inline bool touches_heap() const {
			const auto mi = opcode_.mem_index();
			if ( mi == 3 )
				return false;
			return ((M)get_operand(mi)).is_heap();
		}

		inline Modifier heap_modifier() const {
			assert(touches_heap());
			return modifier(opcode_.mem_index());
		}

		inline RegSet implicit_read_set() const {
			return opcode_.implicit_read_set();
		}

		inline RegSet implicit_write_set() const {
			return opcode_.implicit_write_set();
		}

		inline RegSet implicit_undef_set() const {
			return opcode_.implicit_undef_set();
		}

		RegSet explicit_read_set() const;

		RegSet explicit_write_set() const;

		inline RegSet read_set() const {
			return implicit_read_set() | explicit_read_set();
		}

		inline RegSet write_set() const {
			return implicit_write_set() | explicit_write_set();
		}

		inline RegSet undef_set() const {
			return implicit_undef_set();
		}




OLD OPERAND ENUMS

/** Operand types.
*/
enum Type { 
	REL_8,
	REL_16,
	REL_32,
	AL,
	AX,
	EAX,
	RAX,
	CL,
	R_H,
	R_8,
	R_16,
	R_32,
	R_64,
	IMM_8,
	IMM_16,
	IMM_32,
	IMM_64,
	LABEL,
	M_8,
	M_16,
	M_32,
	M_64,
	M_80,
	M_128,
	M_256,
	MM,
	MOFFS_8,
	MOFFS_16,
	MOFFS_32,
	MOFFS_64,
	SCALE,
	SREG,
	ST0,
	ST,
	XMM,
	XMM0,
	YMM,

	// DEPRECATED -- But required by parser
	ADDR,
	IMM,
	GP_REG,
	MMX_REG,
	XMM_REG,
	FP_REG,
	SEG_REG,
	OFFSET,
	RAX_ONLY,
	RCX_ONLY,
	ST0_ONLY,

	TYPE_NULL
};

// DEPRECATED -- But required by parser
enum BitWidth {
	LOW = 0,
	HIGH,
	WORD,
	DOUBLE,
	QUAD,
	OCT,
	FIXED,

	BIT_WIDTH_NULL
};

/** Operand modifiers.
*/
/*
enum Modifier {
	READ = 0,
	WRITE,
	READ_WRITE,
	NONE,

	MODIFIER_NULL
};
*/

