
#if 0
/** A read-only data structure that presents the ControlFlowGraph 
	  represented by Code.
*/
class ControlFlowGraph {
	public:
		/** Creates a ControlFlowGraph.
			  This constructor will use liveness to determine inputs.
			  Use this only when your code has come from a reliable source.
			  @param code The Code that induces the graph.
		*/
		inline explicit ControlFlowGraph(const Code& code) 
				: code_(code) {
			recompute_blocks();
			recompute_liveness();		
			inputs_ = get_live_ins(location_type(1, 0));
			recompute_defs();
			recompute_back_edges();
			recompute_loops();
		}

		/** Creates a ControlFlowGraph.
			  Use this when your code has come from an unreliable source.
			  @param code The Code that induces the graph.
			  @param inputs Inputs to the ControlFlowGraph.
		*/
		inline explicit ControlFlowGraph(const Code& code, const RegSet& inputs)
				: code_(code), inputs_(inputs) {
			recompute();
		}

		/** Returns an instruction's location in the ControlFlowGraph.
		*/
		inline location_type get_location(size_t idx) const {
			// This will point you beyond empty blocks.  Great!
			assert(idx < code_.size());
			for ( int i = num_blocks()-1; i >= 0; --i )
				if ( idx >= blocks_[i] )
					return std::make_pair(i, idx - blocks_[i]);

			assert(false);
			return std::make_pair(0,0);
		}

		/** Returns the set of registers live in to an instruction.
			  @param loc ControlFlowGraph location, asserts if out of range.
		*/
		inline RegSet get_live_ins(const location_type& loc) const {
			auto rs = get_live_outs(loc);
			const auto& instr = code_[get_index(loc)];
			rs -= instr.write_set();
			rs -= instr.undef_set();
			rs |= instr.read_set();

			return rs;
		}

		/** Returns the set of registers live at a code point.
			  @param idx Instruction index in underlying code, asserts if out of range.
		*/
		inline RegSet get_live_ins(size_t idx) const {
			return get_live_ins(get_location(idx));
		}

		/** Returns the set of registers live out of an instruction.
			  @param loc ControlFlowGraph location, asserts if out of range.
		*/
		inline RegSet get_live_outs(const location_type& loc) const {
			auto rs = live_outs_[loc.first];
			for ( int i = blocks_[loc.first+1]-1, ie = blocks_[loc.first]+loc.second; i > ie; --i ) {
				const auto& instr = code_[i];
				rs -= instr.write_set();
				rs -= instr.undef_set();
				rs |= instr.read_set();
			}
			return rs;
		}

		/** Returns the set of registers live out at a code point.
			  @param idx Instruction index in underlying code, asserts if out of range.
		*/
		inline RegSet get_live_outs(size_t idx) const {
			return get_live_outs(get_location(idx));
		}

		/** Returns the set of registers definitely defined on entry to an 
			  instruction.
			  @param loc ControlFlowGraph location, asserts if out of range.
		*/
		inline RegSet get_def_ins(const location_type& loc) const {
			auto rs = def_ins_[loc.first];
			for ( int i = blocks_[loc.first], ie = i + loc.second; i < ie; ++i ) {
				const auto& instr = code_[i];
				rs |= instr.write_set();
				rs -= instr.undef_set();
			}
			return rs;
		}

		/** Returns the set of registers definitely defined at a code point.
			  @param idx Instruction index in underlying code, asserts if out of range.
		*/
		inline RegSet get_def_ins(size_t idx) const {
			return get_def_ins(get_location(idx));
		}

		/** Returns the set of registers definitely defined on exit from an 
			  instruction.
			  @param loc ControlFlowGraph location, asserts if out of range.
		*/
		inline RegSet get_def_outs(const location_type& loc) const {
			auto rs = get_def_ins(loc);
			const auto& instr = code_[get_index(loc)];
			rs |= instr.write_set();
			rs -= instr.undef_set();

			return rs;
		}

		/** Returns the set of registers definitely defined at a code point.
			  @param idx Instruction index in underlying code, asserts if out of range.
		*/
		inline RegSet get_def_outs(size_t idx) const {
			return get_def_outs(get_location(idx));
		}

		/** Returns true if the underlying code performs an undefined register read.
		*/
		inline bool performs_undef_read() const {
			for ( auto i = reachable_begin(), ie = reachable_end(); i != ie; ++i ) {
				auto di = def_ins_[*i];
				auto idx = blocks_[*i];
				for ( size_t j = 0, je = num_instrs(*i); j < je; ++j ) {
					const auto& instr = code_[idx++];
					const auto reads = instr.read_set();
					if ( (reads & di) != reads )
						return true;
					di |= instr.write_set();
					di -= instr.undef_set();
				}
			}
			return false;
		}

	private:
		RegSet inputs_;

		// Dataflow values for each block
		std::vector<RegSet> live_ins_;
		std::vector<RegSet> live_outs_;

		std::vector<RegSet> def_ins_;
		std::vector<RegSet> def_outs_;

};
#endif





#if 0
#include <algorithm>
#include <map>
#include <stack>

#include "src/code/label.h"
#include "src/io/att_writer.h"

using namespace std;
using namespace x64;

namespace {

void write(ostream& os, const AttWriter& w, const RegSet& rs) {
	for ( auto i = R64::begin(), ie = R64::end(); i != ie; ++i ) {
		if ( rs.is_set((R64)*i) )
			w.write(os, (R64)*i);
		else if ( rs.is_set((R32)*i) )
			w.write(os, (R32)*i);
		else if ( rs.is_set((R16)*i) )
			w.write(os, (R16)*i);
		else if ( rs.is_set((R8)*i) )
			w.write(os, (R8)*i);
		else if ( *i <= bh && rs.is_set((RH)*i) )
			w.write(os, (RH)*i);
	}
}

} // namespace

namespace x64 {

void ControlFlowGraph::recompute_liveness() {
	live_ins_.resize(num_blocks());
	live_outs_.resize(num_blocks());

	// Compute gen/kill sets for blocks
	vector<RegSet> gen(num_blocks());
	vector<RegSet> kill(num_blocks());

	for ( size_t i = get_entry()+1, ie = get_exit(); i < ie; ++i )
		for ( int j = blocks_[i+1]-1, je = blocks_[i]; j >= je; --j ) {
			const auto& instr = code_[j];
			const auto use = instr.read_set();
			const auto def = instr.write_set() | instr.undef_set();

			kill[i] |= def;
			kill[i] -= use;

			gen[i]  -= def;
			gen[i]  |= use;
		}
		
	// Boundary / Initial conditions
	live_ins_[get_exit()] = RegSet().set(rbp).set(rsp).set(rax);
	for ( size_t i = get_entry()+1, ie = get_exit(); i < ie; ++i )
		live_ins_[i] = RegSet();

	// Iterate until fixed point
	for ( bool changed = true; changed; ) {
		changed = false;

		// Meet operator
		for ( size_t i = get_entry()+1, ie = get_exit(); i < ie; ++i ) {
			RegSet new_out;
			for ( auto s = succ_begin(i), se = succ_end(i); s != se; ++s )
				new_out |= live_ins_[*s];

			changed |= (live_outs_[i] != new_out);
			live_outs_[i] = new_out;
		}

		// Transfer function
		for ( size_t i = get_entry()+1, ie = get_exit(); i < ie; ++i ) {
			RegSet new_in = live_outs_[i];
			new_in -= kill[i];
			new_in |= gen[i];

			changed |= (live_ins_[i] != new_in);
			live_ins_[i] = new_in;
		}
	}
}

void ControlFlowGraph::recompute_defs() {
	def_ins_.resize(num_blocks());
	def_outs_.resize(num_blocks());

	// Compute gen sets for blocks
	vector<RegSet> gen(num_blocks());
	for ( size_t i = get_entry()+1, ie = get_exit(); i < ie; ++i )
		for ( auto j = instr_begin(i), je = instr_end(i); j != je; ++j ) {
			gen[i] |= j->write_set();
			gen[i] -= j->undef_set();
		}

	// Boundary / initial conditions
	def_outs_[get_entry()] = get_inputs();
	for ( size_t i = get_entry()+1, ie = get_exit(); i < ie; ++i )
		def_outs_[i] = ~RegSet();

	// Iterate until fixed point
	for ( bool changed = true; changed; ) {
		changed = false;

		// Meet operator
		for ( size_t i = get_entry()+1, ie = get_exit(); i < ie; ++i ) {
			RegSet new_in = ~RegSet();
			for ( auto p = pred_begin(i), pe = pred_end(i); p != pe; ++p )
				new_in &= def_outs_[*p];

			changed |= def_ins_[i] != new_in;
			def_ins_[i] = new_in;
		}

		// Transfer function
		for ( size_t i = get_entry()+1, ie = get_exit(); i < ie; ++i ) {
			RegSet new_out = def_ins_[i];
			new_out |= gen[i];

			changed |= def_outs_[i] != new_out;
			def_outs_[i] = new_out;
		}
	}
}
#endif

